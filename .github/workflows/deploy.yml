name: Deploy to Production

# --- Triggers: automatic on push to main; manual via workflow_dispatch ---
on:
  push:
    branches: ['main']
  workflow_dispatch:

# --- Minimal permissions required for this workflow ---
permissions:
  contents: read

# --- Concurrency: ensure only one production deploy runs at a time ---
concurrency:
  group: deploy-prod
  cancel-in-progress: true

# --- Jobs: build, upload artifacts, switch symlink, cleanup ---
jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    environment:
      name: Production
      url: ${{ env.SITE_URL }}
    # --- Environment variables used by build and remote deployment ---
    env:
      SITE_URL: ${{ vars.SITE_URL }}
      SITE_DOMAIN: ${{ vars.SITE_DOMAIN }}
      PUBLIC_GTM_ID: ${{ vars.PUBLIC_GTM_ID }}
      PUBLIC_ADSENSE_CLIENT: ${{ vars.PUBLIC_ADSENSE_CLIENT }}
      PUBLIC_ADSENSE_SLOT_BLOG_MID: ${{ vars.PUBLIC_ADSENSE_SLOT_BLOG_MID }}
      PUBLIC_ADSENSE_SLOT_BLOG_END: ${{ vars.PUBLIC_ADSENSE_SLOT_BLOG_END }}
      PUBLIC_ADSENSE_SLOT_DL_MID: ${{ vars.PUBLIC_ADSENSE_SLOT_DL_MID }}
      PUBLIC_ADSENSE_SLOT_DL_END: ${{ vars.PUBLIC_ADSENSE_SLOT_DL_END }}
      MINIFY_ENGINE: ${{ vars.MINIFY_ENGINE }}
      KEEP_RELEASES: ${{ vars.KEEP_RELEASES }}
      DEPLOY_BASE_DIR: ${{ vars.DEPLOY_BASE_DIR }}
      RELEASES_DIR: ${{ vars.DEPLOY_BASE_DIR }}/releases
      CURRENT_LINK: ${{ vars.DEPLOY_BASE_DIR }}/current
      SSH_OPTS: -o BatchMode=yes -o ConnectTimeout=120 -o ConnectionAttempts=6 -o ServerAliveInterval=30 -o ServerAliveCountMax=10 -o StrictHostKeyChecking=no -o AddressFamily=inet -o PreferredAuthentications=publickey

    steps:
      # --- Repository checkout ---
      - name: Checkout
        uses: actions/checkout@v4

      # --- Node.js setup ---
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20.18.x'
          cache: 'npm'

      # --- Install and build ---
      - name: Install dependencies
        run: npm ci

      - name: Build
        run: npm run build:clean

      - name: Verify build output & stamp release
        run: |
          set -euo pipefail
          # Ensure `dist` directory exists and contains files
          test -d dist && test "$(find dist -type f | wc -l)" -gt 0 || { echo "❌ dist is empty"; exit 1; }
          # Record commit SHA for traceability
          echo "${GITHUB_SHA}" > dist/.release
          # Record UTC build timestamp
          BUILT_AT="$(date -u +"%Y-%m-%dT%H:%M:%SZ")"
          echo "${BUILT_AT}" > dist/.built_at
          # Publish version.json for deterministic health checks
          printf '{\n  "sha": "%s",\n  "built_at": "%s"\n}\n' "${GITHUB_SHA}" "${BUILT_AT}" > dist/version.json

      # --- SSH setup ---
      - name: Start ssh-agent and add key
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ secrets.SSH_PRIVATE_KEY }}

      - name: Add server to known_hosts
        run: |
          set -euo pipefail
          # Prepare SSH directory and strict permissions
          mkdir -p ~/.ssh && chmod 700 ~/.ssh
          # Pre-populate known_hosts to avoid interactive authenticity prompt
          ssh-keyscan -p "${{ secrets.SSH_PORT }}" -H "${{ secrets.SSH_HOST }}" >> ~/.ssh/known_hosts
          chmod 644 ~/.ssh/known_hosts

      # --- Prepare remote dirs ---
      - name: Prepare remote folders
        run: |
          set -euo pipefail
          ssh -p "${{ secrets.SSH_PORT }}" $SSH_OPTS "${{ secrets.SSH_USER }}@${{ secrets.SSH_HOST }}" "
            set -euo pipefail
            # Ensure releases directory exists on remote host
            mkdir -p '${{ env.RELEASES_DIR }}'
          "

      # --- Upload to releases/<sha> ---
      - name: Rsync dist to releases/<sha>
        env:
          REL_PATH: ${{ github.sha }}
        run: |
          set -euo pipefail
          # Create release directory on remote
          ssh -p "${{ secrets.SSH_PORT }}" $SSH_OPTS "${{ secrets.SSH_USER }}@${{ secrets.SSH_HOST }}" "mkdir -p '${{ env.RELEASES_DIR }}/${REL_PATH}'"
          # Rsync options: archive+compress, delayed delete, partial transfers, auto-create dirs, stats/progress
          RSYNC_OPTS="-az --delete-delay --partial --mkpath --info=stats2,progress2"
          # Upload build artifacts to the remote release path
          rsync $RSYNC_OPTS \
            -e "ssh -p ${{ secrets.SSH_PORT }} $SSH_OPTS" \
            ./dist/ "${{ secrets.SSH_USER }}@${{ secrets.SSH_HOST }}:${{ env.RELEASES_DIR }}/${REL_PATH}/"

      # --- Atomic switch: point `current` to the new release ---
      - name: Activate new release (symlink swap)
        env:
          REL_PATH: ${{ github.sha }}
        run: |
          set -euo pipefail
          ssh -p "${{ secrets.SSH_PORT }}" $SSH_OPTS "${{ secrets.SSH_USER }}@${{ secrets.SSH_HOST }}" "
            set -euo pipefail
            # Atomically update 'current' symlink to point to the new release
            ln -sfn '${{ env.RELEASES_DIR }}/${REL_PATH}' '${{ env.CURRENT_LINK }}'
          "

      # --- Health check ---
      - name: Sanity check index.html exists
        run: |
          set -euo pipefail
          ssh -p "${{ secrets.SSH_PORT }}" $SSH_OPTS "${{ secrets.SSH_USER }}@${{ secrets.SSH_HOST }}" "
            # Verify main entrypoint exists in the active release
            test -f '${{ env.CURRENT_LINK }}/index.html' || { echo '❌ index.html not found in current'; exit 1; }
          "

      # --- Reload Nginx ---
      - name: Reload Nginx
        if: ${{ vars.RELOAD_NGINX == 'true' }}
        run: |
          set -euo pipefail
          # Validate Nginx configuration then reload to apply static file changes (optional)
          ssh -p "${{ secrets.SSH_PORT }}" $SSH_OPTS "${{ secrets.SSH_USER }}@${{ secrets.SSH_HOST }}" "sudo -n nginx -t && sudo -n systemctl reload nginx"

      # --- HTTP Health checks ---
      - name: HTTP health checks
        run: |
          set -euo pipefail
          ROOT_URL="${{ env.SITE_URL }}"
          # HEAD check on root (lightweight)
          STATUS_HEAD="$(curl -fsS -o /dev/null -w "%{http_code}" -I -L --max-time 15 --retry 5 --retry-connrefused -H "Cache-Control: no-cache" -H "Pragma: no-cache" "${ROOT_URL}/?t=${GITHUB_SHA}")"
          test "$STATUS_HEAD" -eq 200 || { echo "❌ HEAD / did not return 200 (got $STATUS_HEAD)"; exit 1; }
          # GET check on root (content retrieval)
          STATUS_GET="$(curl -fsS -o /dev/null -w "%{http_code}" -L --max-time 15 --retry 5 --retry-connrefused -H "Cache-Control: no-cache" -H "Pragma: no-cache" "${ROOT_URL}/?t=${GITHUB_SHA}")"
          test "$STATUS_GET" -eq 200 || { echo "❌ GET / did not return 200 (got $STATUS_GET)"; exit 1; }
          # Asset HEAD checks to validate static files are served via new symlink
          ASSET1_STATUS="$(curl -fsS -o /dev/null -w "%{http_code}" -I --max-time 15 --retry 5 --retry-connrefused "${ROOT_URL}/assets/favicon/favicon.ico?t=${GITHUB_SHA}")"
          test "$ASSET1_STATUS" -eq 200 || { echo "❌ Asset favicon.ico not reachable (got $ASSET1_STATUS)"; exit 1; }
          ASSET2_STATUS="$(curl -fsS -o /dev/null -w "%{http_code}" -I --max-time 15 --retry 5 --retry-connrefused "${ROOT_URL}/assets/profile/logo.svg?t=${GITHUB_SHA}")"
          test "$ASSET2_STATUS" -eq 200 || { echo "❌ Asset logo.svg not reachable (got $ASSET2_STATUS)"; exit 1; }
          # Ensure version.json exists and matches current SHA
          VERSION_JSON="$(curl -fsSL --max-time 15 --retry 5 --retry-connrefused -H "Cache-Control: no-cache" -H "Pragma: no-cache" "${ROOT_URL}/version.json?t=${GITHUB_SHA}")"
          echo "$VERSION_JSON" | grep -q "\"sha\"[[:space:]]*:[[:space:]]*\"${GITHUB_SHA}\"" || { echo "❌ version.json does not contain current SHA"; echo "$VERSION_JSON"; exit 1; }

      # --- Clean up old releases: keep last 5 ---
      - name: Cleanup old releases (keep last ${{ vars.KEEP_RELEASES }})
        run: |
          set -euo pipefail
          ssh -p "${{ secrets.SSH_PORT }}" $SSH_OPTS "${{ secrets.SSH_USER }}@${{ secrets.SSH_HOST }}" "
            set -euo pipefail
            # Navigate to releases directory; exit if it does not exist (fresh server)
            cd '${{ env.RELEASES_DIR }}' || exit 0
            # Determine how many releases to keep; default to 5 if not provided
            KEEP='${{ vars.KEEP_RELEASES }}'
            KEEP=\"\${KEEP:-5}\"
            # Keep only the latest KEEP releases; remove older ones
            ls -1dt */ 2>/dev/null | tail -n +\$(( KEEP + 1 )) | xargs -r rm -rf --
          "

      # --- Upload build artifact (archive) ---
      - name: Upload artifact
        uses: actions/upload-artifact@v4
        with:
          name: dist-${{ github.sha }}
          path: dist
          retention-days: 7
