---
/**
 * SearchInput Component
 *
 * Client-side search input with fuzzy search powered by Fuse.js.
 *
 * Supports two modes:
 * - Inline mode: Search results displayed on same page, URL synced with ?search=
 * - Redirect mode (default): Redirects to /blog/?search=keyword
 *
 * @component
 * @example
 * // Redirect mode (default) - redirects to /blog/?search=keyword
 * <SearchInput placeholder="Search articles..." />
 *
 * // Inline mode - results on same page with URL sync
 * <SearchInput placeholder="Search articles..." mode="inline" />
 */
import Icon from '@components/Icon.astro';
import styles from './search-input.module.css';

interface Props {
  placeholder?: string;
  mode?: 'inline' | 'redirect';
}

const { placeholder = 'Search articles...', mode = 'redirect' } =
  Astro.props as Props;
---

<!-- Search Container -->
<div
  id='search-container'
  class={styles['search-container']}
  role='search'
  aria-label='Cari artikel'
  data-mode={mode}
>
  <form
    id='search-form'
    class={styles['search-form']}
    action='/blog/'
    method='get'
  >
    <div class={styles['search-input-wrapper']}>
      <input
        type='text'
        name='search'
        placeholder={placeholder}
        class={styles['search-input']}
        id='search-input'
        autocomplete='off'
        aria-label='Cari di blog'
      />

      <button
        type='button'
        class={styles['search-clear']}
        id='search-clear'
        aria-label='Clear search'
        style='display: none;'
      >
        <Icon name='btnClose' class={styles['clear-icon']} />
      </button>

      <button
        type='submit'
        class={styles['search-submit']}
        id='search-submit'
        aria-label='Cari'
      >
        <Icon name='blogSearch' class={styles['search-submit-icon']} />
      </button>
    </div>
  </form>

  <!-- Loading Indicator -->
  <div
    class={styles['search-loading']}
    id='search-loading'
    style='display: none;'
  >
    <div class={styles['search-loading-spinner']}></div>
    <span>Mencari...</span>
  </div>
</div>

<script>
  import type Fuse from 'fuse.js';
  import type { FuseResultMatch } from 'fuse.js';
  import { onRouteChange } from '@lib/infrastructure/router-events';
  import type { SearchablePost } from '@lib/content/search';

  interface SearchResult {
    item: SearchablePost;
    score?: number;
    matches?: readonly FuseResultMatch[];
  }

  interface SearchState {
    isInitialized: boolean;
    currentQuery: string;
    mode: 'inline' | 'redirect';
  }

  interface WindowWithSearch extends Window {
    __SEARCH_POSTS__?: SearchablePost[];
    __FUSE_INSTANCE__?: Fuse<SearchablePost>;
  }

  interface SearchResultsEventDetail {
    query: string;
    results: SearchResult[];
    isSearching: boolean;
  }

  const searchState: SearchState = {
    isInitialized: false,
    currentQuery: '',
    mode: 'redirect',
  };

  const FUSE_OPTS = {
    keys: [
      { name: 'title', weight: 0.5 },
      { name: 'excerpt', weight: 0.3 },
      { name: 'content', weight: 0.2 },
      { name: 'category', weight: 0.1 },
    ],
    threshold: 0.3,
    distance: 100,
    includeScore: true,
    includeMatches: true,
    minMatchCharLength: 2,
    ignoreLocation: true,
    useExtendedSearch: false,
  };

  let fuse: Fuse<SearchablePost> | null = null;
  let fuseReady = false;
  let fuseLoadPromise: Promise<void> | null = null;
  let cleanupSearch: (() => void) | null = null;

  async function loadSearchIndex(): Promise<SearchablePost[]> {
    try {
      const res = await fetch('/search-index.json', {
        headers: { Accept: 'application/json' },
      });
      if (!res || !res.ok) return [];
      const data = await res.json();
      if (Array.isArray(data)) {
        const w = window as WindowWithSearch;
        w.__SEARCH_POSTS__ = data as SearchablePost[];
        return data as SearchablePost[];
      }
    } catch (e) {
      console.error('Failed to fetch search index:', e);
    }
    return [];
  }

  async function ensureFuse(postsData: SearchablePost[]): Promise<void> {
    const arr = Array.isArray(postsData) ? postsData : [];
    const w = window as WindowWithSearch;

    if (w.__FUSE_INSTANCE__) {
      fuse = w.__FUSE_INSTANCE__;
      fuseReady = true;
      return;
    }

    const mod = await import('fuse.js');
    const FuseCtor = (mod.default || mod) as typeof Fuse<SearchablePost>;
    fuse = new FuseCtor(arr, FUSE_OPTS);
    fuseReady = true;
    w.__FUSE_INSTANCE__ = fuse;
  }

  function getSearchQueryFromUrl(): string {
    const params = new URLSearchParams(window.location.search);
    return params.get('search') || '';
  }

  function updateUrlWithQuery(query: string): void {
    const url = new URL(window.location.href);
    if (query.trim()) {
      url.searchParams.set('search', query.trim());
    } else {
      url.searchParams.delete('search');
    }
    history.replaceState({}, '', url.toString());
  }

  function emitSearchResults(
    query: string,
    results: SearchResult[],
    isSearching: boolean,
  ): void {
    const event = new CustomEvent<SearchResultsEventDetail>('search:results', {
      detail: { query, results, isSearching },
      bubbles: true,
    });
    document.dispatchEvent(event);

    // For initial page load with query param, retry emission after a short delay
    // to ensure blog search listener is ready
    if (!isSearching && query && results.length >= 0) {
      setTimeout(() => {
        document.dispatchEvent(event);
      }, 50);
    }
  }

  async function loadFuseAndSearch(query: string): Promise<void> {
    if (!fuseLoadPromise) {
      fuseLoadPromise = (async () => {
        const w = window as WindowWithSearch;
        let postsData = w.__SEARCH_POSTS__ || [];
        if (!postsData || postsData.length === 0) {
          postsData = await loadSearchIndex();
        }
        await ensureFuse(postsData);
      })().catch(err => {
        console.error('Failed to load Fuse.js:', err);
      });
    }
    await fuseLoadPromise;
    performSearch(query);
  }

  function initSearch() {
    if (cleanupSearch) {
      cleanupSearch();
      cleanupSearch = null;
    }

    const container = document.getElementById('search-container');
    if (!container) return;

    searchState.mode =
      (container.dataset.mode as 'inline' | 'redirect') || 'redirect';

    const searchForm = document.getElementById(
      'search-form',
    ) as HTMLFormElement;
    const searchInput = document.getElementById(
      'search-input',
    ) as HTMLInputElement;
    const searchClear = document.getElementById(
      'search-clear',
    ) as HTMLButtonElement;
    const searchLoading = document.getElementById(
      'search-loading',
    ) as HTMLDivElement;

    if (!searchForm || !searchInput || !searchClear || !searchLoading) {
      return;
    }

    const initOnce = async () => {
      const w = window as WindowWithSearch;
      const postsData = w.__SEARCH_POSTS__ || [];

      if (!postsData || postsData.length === 0) {
        loadSearchIndex().catch(() => {});
      }

      searchState.isInitialized = true;

      // Inline mode: check URL for initial search query
      if (searchState.mode === 'inline') {
        const initialQuery = getSearchQueryFromUrl();
        if (initialQuery) {
          searchInput.value = initialQuery;
          searchClear.style.display = 'flex';
          await loadFuseAndSearch(initialQuery);
        }
      }
    };

    initOnce();

    // Lazy load Fuse.js on first focus
    const onFirstFocus = () => {
      if (!fuseLoadPromise) {
        fuseLoadPromise = (async () => {
          const w = window as WindowWithSearch;
          let postsData = w.__SEARCH_POSTS__ || [];
          if (!postsData || postsData.length === 0) {
            postsData = await loadSearchIndex();
          }
          await ensureFuse(postsData);
        })().catch(err => {
          console.error('Failed to load Fuse.js:', err);
        });
      }
    };
    searchInput.addEventListener('focus', onFirstFocus, { once: true });

    // Handle form submit
    const onFormSubmit = (e: Event) => {
      const query = searchInput.value.trim();

      if (searchState.mode === 'redirect') {
        // Let form submit naturally to /blog/?search=query
        if (!query) {
          e.preventDefault();
        }
        return;
      }

      // Inline mode: prevent default and handle search
      e.preventDefault();
      searchState.currentQuery = query;
      updateUrlWithQuery(query);

      if (query.length >= 2) {
        performSearch(query);
      } else if (query.length === 0) {
        emitSearchResults('', [], false);
      }
    };
    searchForm.addEventListener('submit', onFormSubmit);

    // Input change handler - show/hide clear button
    const onInput = () => {
      const query = searchInput.value.trim();
      searchClear.style.display = query.length > 0 ? 'flex' : 'none';
    };
    searchInput.addEventListener('input', onInput);

    // Clear search
    const onClearClick = () => {
      searchInput.value = '';
      searchState.currentQuery = '';
      searchClear.style.display = 'none';

      if (searchState.mode === 'inline') {
        updateUrlWithQuery('');
        emitSearchResults('', [], false);
      }

      searchInput.focus();
    };
    searchClear.addEventListener('click', onClearClick);

    // Escape key to clear
    const onKeyDown = (e: KeyboardEvent) => {
      if (e.key === 'Escape') {
        searchInput.blur();
      }
    };
    document.addEventListener('keydown', onKeyDown);

    cleanupSearch = () => {
      searchForm.removeEventListener('submit', onFormSubmit);
      searchInput.removeEventListener('input', onInput);
      searchClear.removeEventListener('click', onClearClick);
      document.removeEventListener('keydown', onKeyDown);
      cleanupSearch = null;
    };
  }

  function performSearch(query: string) {
    if (!searchState.isInitialized || query.length < 2) {
      if (searchState.mode === 'inline' && query.length > 0) {
        emitSearchResults(query, [], false);
      }
      return;
    }

    // Store query in state
    searchState.currentQuery = query;
    emitSearchResults(query, [], true); // Signal searching state

    setTimeout(async () => {
      if (fuseLoadPromise) {
        await fuseLoadPromise;
      }

      let results: SearchResult[] = [];
      if (fuseReady && fuse) {
        const raw = fuse.search(query);
        results = raw.map(r => ({
          item: r.item,
          score: r.score,
          matches: r.matches,
        }));
      }
      // Use the query parameter, not searchState.currentQuery
      emitSearchResults(query, results, false);
    }, 100);
  }

  function initSearchFunction() {
    const container = document.getElementById('search-container');
    if (!container) return;
    if (container.hasAttribute('data-initialized')) return;
    container.setAttribute('data-initialized', 'true');
    initSearch();
  }

  let routerSetup = false;
  function setupRouterReinit() {
    if (routerSetup) return;
    routerSetup = true;

    const run = () => {
      const container = document.getElementById('search-container');
      if (container) {
        container.removeAttribute('data-initialized');
      }
      initSearchFunction();
    };

    document.addEventListener('astro:page-load', run);
    document.addEventListener('astro:after-swap', run);
    onRouteChange(run);
  }

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => {
      initSearchFunction();
      setupRouterReinit();
    });
  } else {
    initSearchFunction();
    setupRouterReinit();
  }
</script>
