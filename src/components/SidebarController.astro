---
// No props; this island centralizes sidebar state, mobile menu, and active nav.
---

<script>
  import { onRouteChange } from '@lib/router-events';

  const STORAGE_KEY: string = 'sidebar-collapsed';
  const MOBILE_QUERY: string = '(max-width: 1024px)';
  function isMobile(): boolean {
    try {
      return !!(window.matchMedia && window.matchMedia(MOBILE_QUERY).matches);
    } catch {
      return false;
    }
  }

  function getCollapsed(): boolean {
    try {
      return localStorage.getItem(STORAGE_KEY) === 'true';
    } catch {
      return false;
    }
  }

  function setCollapsed(v: boolean): void {
    try {
      localStorage.setItem(STORAGE_KEY, v ? 'true' : 'false');
    } catch {}
  }

  function applyStateImmediate(collapsed: boolean): void {
    const sidebar = document.querySelector('.sidebar') as HTMLElement | null;
    if (!sidebar) return;
    let isCollapsed = collapsed;
    if (isMobile()) isCollapsed = false;
    document.documentElement.classList.toggle(
      'sidebar-collapsed-global',
      isCollapsed
    );
    document.documentElement.setAttribute(
      'data-sidebar',
      isCollapsed ? 'collapsed' : 'expanded'
    );
    document.body.classList.toggle('sidebar-collapsed', isCollapsed);
    sidebar.classList.toggle('sidebar-collapsed', isCollapsed);
    sidebar.classList.remove('sidebar-animating', 'hiding-text');
    syncToggleActive();
  }

  function animateToState(collapsed: boolean): void {
    const sidebar = document.querySelector('.sidebar') as HTMLElement | null;
    if (!sidebar) return applyStateImmediate(collapsed);
    if (isMobile()) return applyStateImmediate(false);
    sidebar.classList.add('sidebar-animating');
    if (collapsed) {
      sidebar.classList.add('hiding-text');
      setTimeout(() => {
        document.documentElement.classList.add('sidebar-collapsed-global');
        document.documentElement.setAttribute('data-sidebar', 'collapsed');
        document.body.classList.add('sidebar-collapsed');
        sidebar.classList.add('sidebar-collapsed');
        syncToggleActive();
      }, 120);
      setTimeout(() => {
        sidebar.classList.remove('sidebar-animating');
      }, 360);
    } else {
      document.documentElement.classList.remove('sidebar-collapsed-global');
      document.documentElement.setAttribute('data-sidebar', 'expanded');
      document.body.classList.remove('sidebar-collapsed');
      sidebar.classList.remove('sidebar-collapsed');
      sidebar.classList.add('hiding-text');
      setTimeout(() => {
        sidebar.classList.remove('hiding-text');
      }, 180);
      setTimeout(() => {
        sidebar.classList.remove('sidebar-animating');
      }, 360);
      syncToggleActive();
    }
  }

  function syncToggleActive(): void {
    try {
      const toggleButtons = document.querySelectorAll<HTMLElement>(
        '.sidebar-toggle-button'
      );
      const sidebar = document.querySelector('.sidebar') as HTMLElement | null;
      if (!toggleButtons.length || !sidebar) return;
      const isCollapsedNow =
        document.documentElement.getAttribute('data-sidebar') === 'collapsed' ||
        sidebar.classList.contains('sidebar-collapsed');
      toggleButtons.forEach(btn =>
        btn.classList.toggle('is-active', isCollapsedNow)
      );
    } catch {}
  }

  function applyInitialRootFlags(): void {
    try {
      const shouldCollapse = getCollapsed() && !isMobile();
      document.documentElement.classList.toggle(
        'sidebar-collapsed-global',
        shouldCollapse
      );
      document.documentElement.setAttribute(
        'data-sidebar',
        shouldCollapse ? 'collapsed' : 'expanded'
      );
    } catch {}
  }

  function handleBreakpointChanges(): void {
    try {
      const mq = window.matchMedia(MOBILE_QUERY);
      const handler = () => {
        const sidebarToggle = document.getElementById(
          'sidebar-toggle'
        ) as HTMLInputElement | null;
        if (!sidebarToggle) return;
        if (mq.matches) {
          sidebarToggle.checked = false;
          applyStateImmediate(false);
        } else {
          const collapsed = getCollapsed();
          sidebarToggle.checked = collapsed;
          applyStateImmediate(collapsed);
        }
        syncToggleActive();
      };
      // Apply once immediately
      handler();
      // Prefer modern listener; fallback to onchange without deprecated addListener
      if (typeof (mq as any).addEventListener === 'function')
        (mq as any).addEventListener('change', handler);
      else if ('onchange' in mq) (mq as any).onchange = handler as any;
    } catch {}
  }

  function updateMobileAriaExpanded(): void {
    try {
      const btn = document.querySelector(
        '.navbar-icon-button'
      ) as HTMLElement | null;
      const toggle = document.getElementById(
        'nav-toggle'
      ) as HTMLInputElement | null;
      if (!btn || !toggle) return;
      btn.setAttribute('aria-expanded', toggle.checked ? 'true' : 'false');
    } catch {}
  }

  function closeMobileMenu(): void {
    try {
      const toggle = document.getElementById(
        'nav-toggle'
      ) as HTMLInputElement | null;
      if (!toggle) return;
      if (toggle.checked) {
        toggle.checked = false;
        const btn = document.querySelector('.navbar-icon-button');
        if (btn instanceof HTMLElement) btn.blur();
        updateMobileAriaExpanded();
      }
    } catch {}
  }

  function normalizePath(p: string): string {
    try {
      if (!p) return '/';
      return p.endsWith('/') ? p : p + '/';
    } catch {
      return '/';
    }
  }

  function updateActiveNav(): void {
    try {
      const links = document.querySelectorAll<HTMLAnchorElement>(
        '.sidebar .nav-link-container[href]'
      );
      if (!links || !links.length) return;
      const current = normalizePath(window.location.pathname);
      let best: HTMLAnchorElement | null = null;
      let bestLen = -1;
      links.forEach(link => {
        try {
          const hrefAttr = link.getAttribute('href') || '';
          const hrefPath = normalizePath(
            new URL(hrefAttr, window.location.origin).pathname
          );
          if (current === '/' && hrefPath === '/') {
            if (hrefPath.length > bestLen) {
              best = link;
              bestLen = hrefPath.length;
            }
          } else if (hrefPath !== '/' && current.startsWith(hrefPath)) {
            if (hrefPath.length > bestLen) {
              best = link;
              bestLen = hrefPath.length;
            }
          }
        } catch {}
      });
      links.forEach(link => {
        link.classList.remove('w--current');
        link.removeAttribute('aria-current');
      });
      const b = best as HTMLAnchorElement | null;
      if (b) {
        b.classList.add('w--current');
        b.setAttribute('aria-current', 'page');
      }
    } catch {}
  }

  function attachNavClickHandlers(): void {
    try {
      const links = document.querySelectorAll<HTMLAnchorElement>(
        '.sidebar .nav-link-container[href]'
      );
      if (!links || !links.length) return;
      links.forEach(link => {
        if (link.dataset.navActiveBound === 'true') return;
        link.dataset.navActiveBound = 'true';
        link.addEventListener(
          'click',
          (ev: MouseEvent) => {
            try {
              if (ev.defaultPrevented) return;
              if (ev.metaKey || ev.ctrlKey || ev.shiftKey || ev.altKey) return;
              const hrefAttr = link.getAttribute('href') || '';
              const targetUrl = new URL(hrefAttr, window.location.origin);
              if (targetUrl.origin !== window.location.origin) return;
              closeMobileMenu();
              const all = document.querySelectorAll<HTMLAnchorElement>(
                '.sidebar .nav-link-container[href]'
              );
              all.forEach(a => {
                a.classList.remove('w--current');
                a.removeAttribute('aria-current');
              });
              link.classList.add('w--current');
              link.setAttribute('aria-current', 'page');
              setTimeout(updateActiveNav, 0);
            } catch {}
          },
          { passive: true }
        );
      });
    } catch {}
  }

  declare global {
    interface Window {
      __sidebarControllerRouterBound?: boolean;
    }
  }

  function refreshCollapsedState(): void {
    try {
      const sidebarToggle = document.getElementById(
        'sidebar-toggle'
      ) as HTMLInputElement | null;
      let collapsed = getCollapsed();
      if (isMobile()) collapsed = false;
      if (sidebarToggle) sidebarToggle.checked = collapsed;
      applyStateImmediate(collapsed);
      syncToggleActive();
    } catch {}
  }

  function bindRouterEvents(): void {
    try {
      if (window.__sidebarControllerRouterBound) return;
      window.__sidebarControllerRouterBound = true;
      const reapply = () => {
        refreshCollapsedState();
      };
      document.addEventListener('astro:after-swap', reapply);
      document.addEventListener('astro:page-load', reapply);
      onRouteChange(reapply);
    } catch {}
  }

  function bootOnce(): void {
    const sidebar = document.querySelector('.sidebar') as HTMLElement | null;
    if (!sidebar) return;
    if (sidebar.dataset.controllerInitialized === 'true') return;
    sidebar.dataset.controllerInitialized = 'true';

    // Apply root flags ASAP
    applyInitialRootFlags();
    
    // Re-enable transitions after initial state is applied
    // The inline <head> script sets --sidebar-init-transition: none to prevent
    // animated FOUC on soft reload. After JS controller initializes, we remove
    // the override so subsequent user interactions have smooth transitions.
    requestAnimationFrame(() => {
      try {
        document.documentElement.style.removeProperty('--sidebar-init-transition');
      } catch {}
    });

    // Init state and breakpoint handling
    const sidebarToggle = document.getElementById(
      'sidebar-toggle'
    ) as HTMLInputElement | null;
    if (sidebarToggle) {
      let collapsed = getCollapsed();
      if (isMobile()) collapsed = false;
      sidebarToggle.checked = collapsed;
      applyStateImmediate(collapsed);
      sidebarToggle.addEventListener('change', (ev: Event) => {
        const input = ev.currentTarget as HTMLInputElement;
        if (isMobile()) {
          input.checked = false;
          applyStateImmediate(false);
          setCollapsed(true); // preserve desktop pref
          return;
        }
        animateToState(input.checked);
        setCollapsed(input.checked);
        setTimeout(syncToggleActive, 200);
      });
    } else {
      applyStateImmediate(getCollapsed());
    }

    // Sync ARIA for mobile nav toggle + listen for changes
    const navToggle = document.getElementById(
      'nav-toggle'
    ) as HTMLInputElement | null;
    if (navToggle) {
      updateMobileAriaExpanded();
      navToggle.addEventListener('change', updateMobileAriaExpanded);
      // Focus trap when menu is open
      const siteNav = document.getElementById('site-nav') as HTMLElement | null;
      if (siteNav) {
        const trap = (ev: KeyboardEvent) => {
          if (ev.key !== 'Tab') return;
          if (!navToggle.checked) return;
          const focusables = siteNav.querySelectorAll<HTMLElement>(
            'a[href], button:not([disabled]), [tabindex]:not([tabindex="-1"])'
          );
          if (!focusables.length) return;
          const first = focusables[0];
          const last = focusables[focusables.length - 1];
          const active = document.activeElement as HTMLElement | null;
          if (ev.shiftKey) {
            if (active === first || !siteNav.contains(active)) {
              ev.preventDefault();
              last.focus();
            }
          } else {
            if (active === last || !siteNav.contains(active)) {
              ev.preventDefault();
              first.focus();
            }
          }
        };
        document.addEventListener('keydown', trap);
        // Clean up when menu closes
        navToggle.addEventListener('change', () => {
          if (!navToggle.checked) {
            document.removeEventListener('keydown', trap);
          }
        });
      }
    }

    handleBreakpointChanges();

    // Nav handling
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', () => {
        closeMobileMenu();
        updateActiveNav();
        attachNavClickHandlers();
      });
    } else {
      closeMobileMenu();
      updateActiveNav();
      attachNavClickHandlers();
    }
    const refreshNavState = () => {
      try {
        queueMicrotask(() => {
          closeMobileMenu();
          updateActiveNav();
        });
      } catch {
        setTimeout(() => {
          closeMobileMenu();
          updateActiveNav();
        }, 0);
      }
    };
    onRouteChange(refreshNavState);
  }

  // Run once on load; sidebar persists via data-astro-transition-persist
  bootOnce();
  bindRouterEvents();
</script>
