---
import Icon from './Icon.astro';
import styles from './SearchInput/search-input.module.css';

interface Props {
  posts?: any[];
  placeholder?: string;
}

const { placeholder = 'Search articles...' } = Astro.props as Props;
---

<div
  id='search-container'
  class={styles['search-container']}
  role='search'
  aria-label='Cari artikel'
>
  <div class={styles['search-input-wrapper']}>
    <Icon name='search' class={styles['search-icon']} />
    <input
      type='text'
      placeholder={placeholder}
      class={styles['search-input']}
      id='search-input'
      autocomplete='off'
      aria-autocomplete='list'
      aria-controls='search-results'
      aria-expanded='false'
      aria-label='Cari di blog'
    />
    <button
      type='button'
      class={styles['search-clear']}
      id='search-clear'
      aria-label='Clear search'
      style='display: none;'
    >
      <Icon name='close' class={styles['clear-icon']} />
    </button>
  </div>
  <div
    class={styles['search-results']}
    id='search-results'
    style='display: none;'
    role='listbox'
    aria-label='Hasil pencarian'
  >
    <div
      class={styles['search-results-content']}
      id='search-results-content'
      aria-live='polite'
    >
    </div>
  </div>
  <div
    class={styles['search-loading']}
    id='search-loading'
    style='display: none;'
  >
    <div class={styles['search-loading-spinner']}></div>
    <span>Mencari...</span>
  </div>
</div>

<script>
  import { onRouteChange } from '@lib/router-events';

  // SearchResult type is used in the script below
  interface SearchResult {
    item: any;
    score?: number;
    matches?: Array<{
      indices: [number, number][];
      key: string;
      value: string;
    }>;
  }

  interface SearchState {
    isInitialized: boolean;
    currentQuery: string;
    isSearching: boolean;
  }

  const searchState: SearchState = {
    isInitialized: false,
    currentQuery: '',
    isSearching: false,
  };

  // Fuse.js options (lazy-imported)
  const FUSE_OPTS = {
    keys: [
      { name: 'title', weight: 0.5 },
      { name: 'excerpt', weight: 0.3 },
      { name: 'content', weight: 0.2 },
      { name: 'category', weight: 0.1 },
    ],
    threshold: 0.3,
    includeScore: true,
    includeMatches: true,
    minMatchCharLength: 2,
    ignoreLocation: true,
  };

  let fuse: any = null;
  let fuseReady = false;
  let cleanupSearch: (() => void) | null = null;

  async function loadSearchIndex(): Promise<any[]> {
    try {
      const res = await fetch('/search-index.json', {
        headers: { Accept: 'application/json' },
      });
      if (!res || !res.ok) return [];
      const data = await res.json();
      if (Array.isArray(data)) {
        (window as any).__SEARCH_POSTS__ = data;
        return data;
      }
    } catch (e) {
      console.error('Failed to fetch search index:', e);
    }
    return [];
  }
  async function ensureFuse(postsData: any[]): Promise<void> {
    const arr = Array.isArray(postsData) ? postsData : [];
    const signatureOf = (list: any[]): string => {
      try {
        return (
          list.length +
          ':' +
          list.map((it: any) => it.slug || it.id || '').join('|')
        );
      } catch {
        return `${Date.now()}:${list.length}`;
      }
    };
    const nextSig = signatureOf(arr);

    const mod: any = await import('fuse.js');
    const FuseCtor = mod.default || mod;

    if (!fuse) {
      fuse = new FuseCtor(arr, FUSE_OPTS);
      (fuse as any).__signature = nextSig;
      fuseReady = true;
      return;
    }

    const prevSig = (fuse as any).__signature;
    if (prevSig !== nextSig) {
      if (typeof (fuse as any).setCollection === 'function') {
        (fuse as any).setCollection(arr);
        (fuse as any).__signature = nextSig;
      } else {
        fuse = new FuseCtor(arr, FUSE_OPTS);
        (fuse as any).__signature = nextSig;
      }
    }
    fuseReady = true;
  }

  function escapeHtml(s: string): string {
    const map: Record<string, string> = {
      '&': '&amp;',
      '<': '&lt;',
      '>': '&gt;',
      '"': '&quot;',
      "'": '&#39;',
    };
    return String(s).replace(/[&<>"']/g, c => map[c] || c);
  }

  // Initialize search functionality
  function initSearch() {
    // Remove any existing listeners before re-initializing
    if (cleanupSearch) {
      cleanupSearch();
      cleanupSearch = null;
    }

    // Only initialize if the SearchInput component exists on the page
    const container = document.getElementById('search-container');
    if (!container) {
      return;
    }

    const searchInput = document.getElementById(
      'search-input'
    ) as HTMLInputElement;
    const searchClear = document.getElementById(
      'search-clear'
    ) as HTMLButtonElement;
    const searchResults = document.getElementById(
      'search-results'
    ) as HTMLDivElement;
    const searchResultsContent = document.getElementById(
      'search-results-content'
    ) as HTMLDivElement;
    const searchLoading = document.getElementById(
      'search-loading'
    ) as HTMLDivElement;

    if (
      !searchInput ||
      !searchClear ||
      !searchResults ||
      !searchResultsContent ||
      !searchLoading
    ) {
      return;
    }

    // Initialize search
    // Wait for data to be available
    const initOnce = async () => {
      const postsData = (window as any).__SEARCH_POSTS__ || [];

      if (!postsData || postsData.length === 0) {
        // Fire-and-forget fetch to prime the cache; performSearch will also fetch on demand
        loadSearchIndex().catch(() => {});
      }

      // Always enable search immediately to avoid dev polling loop
      searchState.isInitialized = true;
    };

    // Start initialization
    initOnce();

    // Search input event handlers
    let searchTimeout: number | null = null;
    const onInput = (e: Event) => {
      const query = (e.target as HTMLInputElement).value.trim();
      searchState.currentQuery = query;

      // Clear previous timeout
      if (searchTimeout !== null) {
        clearTimeout(searchTimeout);
        searchTimeout = null;
      }

      // Show/hide clear button
      if (query.length > 0) {
        searchClear.style.display = 'flex';
      } else {
        searchClear.style.display = 'none';
        hideResults();
        return;
      }

      // Debounce search
      searchTimeout = window.setTimeout(() => {
        performSearch(query);
      }, 300);
    };
    searchInput.addEventListener('input', onInput);

    // Clear search
    const onClearClick = () => {
      searchInput.value = '';
      searchState.currentQuery = '';
      searchClear.style.display = 'none';
      hideResults();
    };
    searchClear.addEventListener('click', onClearClick);

    // Hide results when clicking outside
    const onDocumentClick = (e: MouseEvent) => {
      const target = e.target as Element;
      // Use stable container id for click-outside detection
      const container = document.getElementById('search-container');
      if (container && !container.contains(target)) {
        hideResults();
      }
    };
    document.addEventListener('click', onDocumentClick);

    // Handle escape key
    const onDocumentKeyDown = (e: KeyboardEvent) => {
      if (e.key === 'Escape') {
        hideResults();
        searchInput.blur();
      }

      // Keyboard navigation
      if (e.key === 'ArrowDown' || e.key === 'ArrowUp') {
        const items = Array.from(
          document.querySelectorAll('.search-result-item')
        ) as HTMLElement[];
        if (items.length === 0) return;
        const active = items.findIndex(el =>
          el.classList.contains('is-active')
        );
        let nextIndex = e.key === 'ArrowDown' ? active + 1 : active - 1;
        if (active === -1)
          nextIndex = e.key === 'ArrowDown' ? 0 : items.length - 1;
        if (nextIndex < 0) nextIndex = items.length - 1;
        if (nextIndex >= items.length) nextIndex = 0;
        items.forEach(el => el.classList.remove('is-active'));
        const next = items[nextIndex];
        next.classList.add('is-active');
        next.scrollIntoView({ block: 'nearest' });
        e.preventDefault();
      }

      if (e.key === 'Enter') {
        const active = document.querySelector(
          '.search-result-item.is-active'
        ) as HTMLElement | null;
        if (active) {
          const slug = active.getAttribute('data-slug');
          if (slug) window.location.href = `/blog/${slug}/`;
        }
      }
    };
    document.addEventListener('keydown', onDocumentKeyDown);

    cleanupSearch = () => {
      if (searchTimeout !== null) {
        clearTimeout(searchTimeout);
        searchTimeout = null;
      }
      searchInput.removeEventListener('input', onInput);
      searchClear.removeEventListener('click', onClearClick);
      document.removeEventListener('click', onDocumentClick);
      document.removeEventListener('keydown', onDocumentKeyDown);
      cleanupSearch = null;
    };
  }

  function performSearch(query: string) {
    if (!searchState.isInitialized || query.length < 2) {
      return;
    }

    searchState.isSearching = true;
    showLoading();

    // Fuse-based client-side search with lazy import
    setTimeout(async () => {
      let postsData = (window as any).__SEARCH_POSTS__ || [];
      if (!postsData || postsData.length === 0) {
        postsData = await loadSearchIndex();
      }
      try {
        await ensureFuse(postsData);
      } catch (e) {
        console.error('Gagal inisialisasi Fuse:', e);
      }

      let results: SearchResult[] = [];
      if (fuseReady && fuse) {
        const raw = fuse.search(query);
        // Fuse returns sorted results (lower score = more relevant)
        results = raw.map((r: any) => ({
          item: r.item,
          score: r.score,
          matches: r.matches,
        }));
      }
      handleSearchResults(results);
    }, 100);
  }

  function handleSearchResults(results: SearchResult[]) {
    searchState.isSearching = false;
    hideLoading();

    const searchResults = document.getElementById(
      'search-results'
    ) as HTMLDivElement;
    const searchResultsContent = document.getElementById(
      'search-results-content'
    ) as HTMLDivElement;

    if (!searchResults || !searchResultsContent) return;

    if (results.length === 0) {
      searchResultsContent.innerHTML = `
        <div class="search-no-results">
          <p>Tidak ada artikel untuk "${searchState.currentQuery}"</p>
        </div>
      `;
    } else {
      searchResultsContent.innerHTML = results
        .map(result => {
          return `
        <div class="search-result-item" role="option" tabindex="0" data-slug="${result.item.slug}">
          <div class="search-result-body">
            <h3 class="search-result-title">${highlightMatches(result.item.title, result.matches, 'title')}</h3>
            ${result.item.excerpt ? `<p class="search-result-excerpt">${highlightMatches(result.item.excerpt, result.matches, 'excerpt')}</p>` : ''}
            <div class="search-result-meta">
              ${result.item.category ? `<span class="search-result-category">${result.item.category}</span>` : ''}
              ${result.item.dateLabel ? `<span class="search-result-date">${result.item.dateLabel}</span>` : ''}
            </div>
          </div>
        </div>`;
        })
        .join('');

      // Add click handlers to result items
      searchResultsContent
        .querySelectorAll('.search-result-item')
        .forEach(item => {
          item.addEventListener('click', () => {
            const slug = item.getAttribute('data-slug');
            if (slug) {
              window.location.href = `/blog/${slug}/`;
            }
          });
          item.addEventListener('mouseover', () => {
            document
              .querySelectorAll('.search-result-item')
              .forEach(el => el.classList.remove('is-active'));
            item.classList.add('is-active');
          });
        });
    }

    showResults();
    // Update ARIA expanded
    const searchInput = document.getElementById(
      'search-input'
    ) as HTMLInputElement | null;
    if (searchInput) searchInput.setAttribute('aria-expanded', 'true');
  }

  function highlightMatches(
    text: string,
    matches: any[] | undefined,
    key: string
  ): string {
    if (!matches) return escapeHtml(text);

    const match = matches.find(m => m.key === key);
    if (!match || !match.indices || match.indices.length === 0)
      return escapeHtml(text);

    const isWordChar = (ch: string) => /\p{L}|\p{N}|_/u.test(ch);
    const expandToWordBoundaries = (
      t: string,
      s: number,
      e: number
    ): [number, number] => {
      let start = s;
      let end = e;
      while (start > 0 && isWordChar(t[start - 1])) start--;
      while (end + 1 < t.length && isWordChar(t[end + 1])) end++;
      return [start, end];
    };

    // Extend to word boundaries and merge intersecting ranges
    const ranges: [number, number][] = match.indices
      .map(([s, e]: [number, number]) => expandToWordBoundaries(text, s, e))
      .sort((a: [number, number], b: [number, number]) => a[0] - b[0]);

    const merged: [number, number][] = [];
    for (const [s, e] of ranges) {
      if (merged.length === 0) {
        merged.push([s, e]);
      } else {
        const last = merged[merged.length - 1];
        if (s <= last[1] + 1) {
          last[1] = Math.max(last[1], e);
        } else {
          merged.push([s, e]);
        }
      }
    }

    let highlighted = '';
    let lastIndex = 0;

    for (const [start, end] of merged) {
      highlighted += escapeHtml(text.slice(lastIndex, start));
      highlighted += `<mark class="search-highlight">${escapeHtml(text.slice(start, end + 1))}</mark>`;
      lastIndex = end + 1;
    }

    highlighted += escapeHtml(text.slice(lastIndex));
    return highlighted;
  }

  function showResults() {
    const searchResults = document.getElementById(
      'search-results'
    ) as HTMLDivElement;
    if (searchResults) {
      searchResults.style.display = 'block';
    }
  }

  function hideResults() {
    const searchResults = document.getElementById(
      'search-results'
    ) as HTMLDivElement;
    if (searchResults) {
      searchResults.style.display = 'none';
    }
    const searchInput = document.getElementById(
      'search-input'
    ) as HTMLInputElement | null;
    if (searchInput) searchInput.setAttribute('aria-expanded', 'false');
  }

  function showLoading() {
    const searchLoading = document.getElementById(
      'search-loading'
    ) as HTMLDivElement;
    if (searchLoading) {
      searchLoading.style.display = 'flex';
    }
  }

  function hideLoading() {
    const searchLoading = document.getElementById(
      'search-loading'
    ) as HTMLDivElement;
    if (searchLoading) {
      searchLoading.style.display = 'none';
    }
  }

  // Initialize search function
  function initSearchFunction() {
    // Only run when the component's container is present
    const container = document.getElementById('search-container');
    if (!container) return;
    initSearch();
  }

  // Setup router reinit for ClientRouter compatibility
  let routerSetup = false;
  function setupRouterReinit() {
    if (routerSetup) return;
    routerSetup = true;

    const run = () => initSearchFunction();

    // Astro transitions events (if ClientRouter is used)
    document.addEventListener('astro:page-load', run);
    document.addEventListener('astro:after-swap', run);

    onRouteChange(run);

    // Observe DOM changes to catch newly injected content
    const debounced = (() => {
      let t: number | null = null;
      return () => {
        if (t) window.clearTimeout(t);
        t = window.setTimeout(() => {
          run();
          t = null;
        }, 25);
      };
    })();

    const observer = new MutationObserver(debounced);
    observer.observe(document.body, { childList: true, subtree: true });
  }

  // Initialize when DOM is ready
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => {
      initSearchFunction();
      setupRouterReinit();
    });
  } else {
    initSearchFunction();
    setupRouterReinit();
  }
</script>
