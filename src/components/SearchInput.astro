---
import Icon from "./Icon.astro";
import styles from "./SearchInput/search-input.module.css";

interface Props {
  posts?: any[];
  placeholder?: string;
}

const { placeholder = "Search articles..." } = Astro.props as Props;
---

<div id="search-container" class={styles['search-container']} role="search" aria-label="Cari artikel">
  <div class={styles['search-input-wrapper']}>
    <Icon name="search" class={styles['search-icon']} />
    <input
      type="text"
      placeholder={placeholder}
      class={styles['search-input']}
      id="search-input"
      autocomplete="off"
      aria-autocomplete="list"
      aria-controls="search-results"
      aria-expanded="false"
      aria-label="Cari di blog"
    />
    <button
      type="button"
      class={styles['search-clear']}
      id="search-clear"
      aria-label="Clear search"
      style="display: none;"
    >
      <Icon name="close" class={styles['clear-icon']} />
    </button>
  </div>
  <div class={styles['search-results']} id="search-results" style="display: none;" role="listbox" aria-label="Hasil pencarian">
    <div class={styles['search-results-content']} id="search-results-content" aria-live="polite">
      <!-- Results will be populated by JavaScript -->
    </div>
  </div>
  <div class={styles['search-loading']} id="search-loading" style="display: none;">
    <div class={styles['search-loading-spinner']}></div>
    <span>Mencari...</span>
  </div>
</div>

<script>
  // SearchResult type is used in the script below
  interface SearchResult {
    item: any;
    score?: number;
    matches?: Array<{
      indices: [number, number][];
      key: string;
      value: string;
    }>;
  }

  interface SearchState {
    isInitialized: boolean;
    currentQuery: string;
    isSearching: boolean;
  }

  const searchState: SearchState = {
    isInitialized: false,
    currentQuery: '',
    isSearching: false,
  };

  // Fuse.js options (lazy-imported)
  const FUSE_OPTS = {
    keys: [
      { name: 'title', weight: 0.5 },
      { name: 'excerpt', weight: 0.3 },
      { name: 'content', weight: 0.2 },
      { name: 'category', weight: 0.1 },
    ],
    threshold: 0.3,
    includeScore: true,
    includeMatches: true,
    minMatchCharLength: 2,
    ignoreLocation: true,
  };

  let fuse: any = null;
  let fuseReady = false;


  async function loadSearchIndex(): Promise<any[]> {
    try {
      const res = await fetch('/search-index.json', {
        headers: { Accept: 'application/json' },
      });
      if (!res || !res.ok) return [];
      const data = await res.json();
      if (Array.isArray(data)) {
        (window as any).__SEARCH_POSTS__ = data;
        return data;
      }
    } catch (e) {
      console.error('Failed to fetch search index:', e);
    }
    return [];
  }
  async function ensureFuse(postsData: any[]): Promise<void> {
    if (fuse) return;
    const mod: any = await import('fuse.js');
    const Fuse = mod.default || mod;
    fuse = new Fuse(postsData, FUSE_OPTS);
    fuseReady = true;
  }

  function escapeHtml(s: string): string {
    const map: Record<string, string> = {
      '&': '&',
      '<': '<',
      '>': '>',
      '"': '"',
      "'": '&#39;',
    };
    return String(s).replace(/[&<>"']/g, (c) => map[c] || c);
  }
 
  // Initialize search functionality
  function initSearch() {
    // Only initialize if the SearchInput component exists on the page
    const container = document.getElementById('search-container');
    if (!container) {
      return;
    }

    const searchInput = document.getElementById('search-input') as HTMLInputElement;
    const searchClear = document.getElementById('search-clear') as HTMLButtonElement;
    const searchResults = document.getElementById('search-results') as HTMLDivElement;
    const searchResultsContent = document.getElementById('search-results-content') as HTMLDivElement;
    const searchLoading = document.getElementById('search-loading') as HTMLDivElement;

    if (!searchInput || !searchClear || !searchResults || !searchResultsContent || !searchLoading) {
      return;
    }

    // Initialize search
    // Wait for data to be available
    const initSearch = async () => {
      let postsData = (window as any).__SEARCH_POSTS__ || [];
      
      if (!postsData || postsData.length === 0) {
        postsData = await loadSearchIndex();
      }

      if (postsData && postsData.length > 0) {
        searchState.isInitialized = true;
      } else {
        setTimeout(initSearch, 400);
      }
    };
    
    // Start initialization
    initSearch();

    // Search input event handlers
    let searchTimeout: number;
    searchInput.addEventListener('input', (e) => {
      const query = (e.target as HTMLInputElement).value.trim();
      searchState.currentQuery = query;
      
      // Clear previous timeout
      clearTimeout(searchTimeout);
      
      // Show/hide clear button
      if (query.length > 0) {
        searchClear.style.display = 'flex';
      } else {
        searchClear.style.display = 'none';
        hideResults();
        return;
      }
      
      // Debounce search
      searchTimeout = window.setTimeout(() => {
        performSearch(query);
      }, 300);
    });

    // Clear search
    searchClear.addEventListener('click', () => {
      searchInput.value = '';
      searchState.currentQuery = '';
      searchClear.style.display = 'none';
      hideResults();
    });

    // Hide results when clicking outside
    document.addEventListener('click', (e) => {
      const target = e.target as Element;
      // Use stable container id for click-outside detection
      const container = document.getElementById('search-container');
      if (container && !container.contains(target)) {
        hideResults();
      }
    });

    // Handle escape key
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape') {
        hideResults();
        searchInput.blur();
      }

      // Keyboard navigation
      if (e.key === 'ArrowDown' || e.key === 'ArrowUp') {
        const items = Array.from(document.querySelectorAll('.search-result-item')) as HTMLElement[];
        if (items.length === 0) return;
        const active = items.findIndex(el => el.classList.contains('is-active'));
        let nextIndex = e.key === 'ArrowDown' ? active + 1 : active - 1;
        if (active === -1) nextIndex = e.key === 'ArrowDown' ? 0 : items.length - 1;
        if (nextIndex < 0) nextIndex = items.length - 1;
        if (nextIndex >= items.length) nextIndex = 0;
        items.forEach(el => el.classList.remove('is-active'));
        const next = items[nextIndex];
        next.classList.add('is-active');
        next.scrollIntoView({ block: 'nearest' });
        e.preventDefault();
      }

      if (e.key === 'Enter') {
        const active = document.querySelector('.search-result-item.is-active') as HTMLElement | null;
        if (active) {
          const slug = active.getAttribute('data-slug');
          if (slug) window.location.href = `/blog/${slug}/`;
        }
      }
    });
  }

  function performSearch(query: string) {
    if (!searchState.isInitialized || query.length < 2) {
      return;
    }

    searchState.isSearching = true;
    showLoading();

    // Fuse-based client-side search with lazy import
    setTimeout(async () => {
      let postsData = (window as any).__SEARCH_POSTS__ || [];
      if (!postsData || postsData.length === 0) {
        postsData = await loadSearchIndex();
      }
      try {
        await ensureFuse(postsData);
      } catch (e) {
        console.error('Gagal inisialisasi Fuse:', e);
      }

      let results: SearchResult[] = [];
      if (fuseReady && fuse) {
        const raw = fuse.search(query);
        // Fuse returns sorted results (lower score = more relevant)
        results = raw.map((r: any) => ({
          item: r.item,
          score: r.score,
          matches: r.matches,
        }));
      }
      handleSearchResults(results);
    }, 100);
  }

  function handleSearchResults(results: SearchResult[]) {
    searchState.isSearching = false;
    hideLoading();
    
    const searchResults = document.getElementById('search-results') as HTMLDivElement;
    const searchResultsContent = document.getElementById('search-results-content') as HTMLDivElement;
    
    if (!searchResults || !searchResultsContent) return;
    
    if (results.length === 0) {
      searchResultsContent.innerHTML = `
        <div class="search-no-results">
          <p>Tidak ada artikel untuk "${searchState.currentQuery}"</p>
        </div>
      `;
    } else {
      searchResultsContent.innerHTML = results.map(result => {
        const img = result.item.heroSrc ? `<img src="${result.item.heroSrc}" alt="${result.item.title}" class="search-result-thumb" loading="lazy" />` : '';
        return `
        <div class="search-result-item" role="option" tabindex="0" data-slug="${result.item.slug}">
          ${img}
          <div class="search-result-body">
            <h3 class="search-result-title">${highlightMatches(result.item.title, result.matches, 'title')}</h3>
            ${result.item.excerpt ? `<p class="search-result-excerpt">${highlightMatches(result.item.excerpt, result.matches, 'excerpt')}</p>` : ''}
            <div class="search-result-meta">
              ${result.item.category ? `<span class="search-result-category">${result.item.category}</span>` : ''}
              ${result.item.dateLabel ? `<span class="search-result-date">${result.item.dateLabel}</span>` : ''}
            </div>
          </div>
        </div>`;
      }).join('');
      
      // Add click handlers to result items
      searchResultsContent.querySelectorAll('.search-result-item').forEach(item => {
        item.addEventListener('click', () => {
          const slug = item.getAttribute('data-slug');
          if (slug) {
            window.location.href = `/blog/${slug}/`;
          }
        });
        item.addEventListener('mouseover', () => {
          document.querySelectorAll('.search-result-item').forEach(el => el.classList.remove('is-active'));
          item.classList.add('is-active');
        });
      });
    }
    
    showResults();
    // Update ARIA expanded
    const searchInput = document.getElementById('search-input') as HTMLInputElement | null;
    if (searchInput) searchInput.setAttribute('aria-expanded', 'true');
  }

  function highlightMatches(text: string, matches: any[] | undefined, key: string): string {
    if (!matches) return escapeHtml(text);

    const match = matches.find((m) => m.key === key);
    if (!match || !match.indices || match.indices.length === 0) return escapeHtml(text);

    // Sort indices to ensure correct order
    const indices: [number, number][] = match.indices.slice().sort((a: [number, number], b: [number, number]) => a[0] - b[0]);

    let highlighted = '';
    let lastIndex = 0;

    for (const [start, end] of indices) {
      highlighted += escapeHtml(text.slice(lastIndex, start));
      highlighted += `<mark class="search-highlight">${escapeHtml(text.slice(start, end + 1))}</mark>`;
      lastIndex = end + 1;
    }

    highlighted += escapeHtml(text.slice(lastIndex));
    return highlighted;
  }
 
  function showResults() {
    const searchResults = document.getElementById('search-results') as HTMLDivElement;
    if (searchResults) {
      searchResults.style.display = 'block';
    }
  }

  function hideResults() {
    const searchResults = document.getElementById('search-results') as HTMLDivElement;
    if (searchResults) {
      searchResults.style.display = 'none';
    }
    const searchInput = document.getElementById('search-input') as HTMLInputElement | null;
    if (searchInput) searchInput.setAttribute('aria-expanded', 'false');
  }

  function showLoading() {
    const searchLoading = document.getElementById('search-loading') as HTMLDivElement;
    if (searchLoading) {
      searchLoading.style.display = 'flex';
    }
  }

  function hideLoading() {
    const searchLoading = document.getElementById('search-loading') as HTMLDivElement;
    if (searchLoading) {
      searchLoading.style.display = 'none';
    }
  }

  // Initialize search function
  function initSearchFunction() {
    // Only run when the component's container is present
    const container = document.getElementById('search-container');
    if (!container) return;
    initSearch();
  }

  // Setup router reinit for ClientRouter compatibility
  let routerSetup = false;
  function setupRouterReinit() {
    if (routerSetup) return;
    routerSetup = true;

    const run = () => initSearchFunction();

    // Astro transitions events (if ClientRouter is used)
    document.addEventListener('astro:page-load', run);
    document.addEventListener('astro:after-swap', run);

    // Navigation via history
    window.addEventListener('popstate', run);
    const _push = history.pushState?.bind(history);
    if (_push) {
      history.pushState = function (
        data: any,
        unused: string,
        url?: string | URL | null
      ) {
        const ret = _push(data, unused, url);
        // re-bind after navigation
        setTimeout(run, 10);
        return ret;
      } as typeof history.pushState;
    }

    // Observe DOM changes to catch newly injected content
    const debounced = (() => {
      let t: number | null = null;
      return () => {
        if (t) window.clearTimeout(t);
        t = window.setTimeout(() => {
          run();
          t = null;
        }, 25);
      };
    })();

    const observer = new MutationObserver(debounced);
    observer.observe(document.body, { childList: true, subtree: true });
  }

  // Initialize when DOM is ready
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => {
      initSearchFunction();
      setupRouterReinit();
    });
  } else {
    initSearchFunction();
    setupRouterReinit();
  }
</script>
