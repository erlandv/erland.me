---
import Icon from "./Icon.astro";
import styles from "./SearchInput/search-input.module.css";

interface Props {
  posts: any[];
  placeholder?: string;
}

const { placeholder = "Search articles..." } = Astro.props as Props;
---

<div id="search-container" class={styles['search-container']} role="search" aria-label="Cari artikel">
  <div class={styles['search-input-wrapper']}>
    <Icon name="search" class={styles['search-icon']} />
    <input
      type="text"
      placeholder={placeholder}
      class={styles['search-input']}
      id="search-input"
      autocomplete="off"
      aria-autocomplete="list"
      aria-controls="search-results"
      aria-expanded="false"
      aria-label="Cari di blog"
    />
    <button
      type="button"
      class={styles['search-clear']}
      id="search-clear"
      aria-label="Clear search"
      style="display: none;"
    >
      <Icon name="close" class={styles['clear-icon']} />
    </button>
  </div>
  <div class={styles['search-results']} id="search-results" style="display: none;" role="listbox" aria-label="Hasil pencarian">
    <div class={styles['search-results-content']} id="search-results-content" aria-live="polite">
      <!-- Results will be populated by JavaScript -->
    </div>
  </div>
  <div class={styles['search-loading']} id="search-loading" style="display: none;">
    <div class={styles['search-loading-spinner']}></div>
    <span>Mencari...</span>
  </div>
</div>

<script>
  // SearchResult type is used in the script below
  interface SearchResult {
    item: any;
    score?: number;
    matches?: Array<{
      indices: [number, number][];
      key: string;
      value: string;
    }>;
  }

  interface SearchState {
    isInitialized: boolean;
    currentQuery: string;
    isSearching: boolean;
  }

  const searchState: SearchState = {
    isInitialized: false,
    currentQuery: '',
    isSearching: false,
  };

  // Initialize search functionality
  function initSearch() {
    const searchInput = document.getElementById('search-input') as HTMLInputElement;
    const searchClear = document.getElementById('search-clear') as HTMLButtonElement;
    const searchResults = document.getElementById('search-results') as HTMLDivElement;
    const searchResultsContent = document.getElementById('search-results-content') as HTMLDivElement;
    const searchLoading = document.getElementById('search-loading') as HTMLDivElement;

    if (!searchInput || !searchClear || !searchResults || !searchResultsContent || !searchLoading) {
      console.error('Search elements not found');
      return;
    }

    // Initialize search
    // Wait for data to be available
    const initSearch = () => {
      const postsData = (window as any).__SEARCH_POSTS__ || [];
      
      if (postsData.length > 0) {
        searchState.isInitialized = true;
      } else {
        setTimeout(initSearch, 200);
      }
    };
    
    // Start initialization
    initSearch();

    // Search input event handlers
    let searchTimeout: number;
    searchInput.addEventListener('input', (e) => {
      const query = (e.target as HTMLInputElement).value.trim();
      searchState.currentQuery = query;
      
      // Clear previous timeout
      clearTimeout(searchTimeout);
      
      // Show/hide clear button
      if (query.length > 0) {
        searchClear.style.display = 'flex';
      } else {
        searchClear.style.display = 'none';
        hideResults();
        return;
      }
      
      // Debounce search
      searchTimeout = window.setTimeout(() => {
        performSearch(query);
      }, 300);
    });

    // Clear search
    searchClear.addEventListener('click', () => {
      searchInput.value = '';
      searchState.currentQuery = '';
      searchClear.style.display = 'none';
      hideResults();
    });

    // Hide results when clicking outside
    document.addEventListener('click', (e) => {
      const target = e.target as Element;
      // Use stable container id for click-outside detection
      const container = document.getElementById('search-container');
      if (container && !container.contains(target)) {
        hideResults();
      }
    });

    // Handle escape key
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape') {
        hideResults();
        searchInput.blur();
      }

      // Keyboard navigation
      if (e.key === 'ArrowDown' || e.key === 'ArrowUp') {
        const items = Array.from(document.querySelectorAll('.search-result-item')) as HTMLElement[];
        if (items.length === 0) return;
        const active = items.findIndex(el => el.classList.contains('is-active'));
        let nextIndex = e.key === 'ArrowDown' ? active + 1 : active - 1;
        if (active === -1) nextIndex = e.key === 'ArrowDown' ? 0 : items.length - 1;
        if (nextIndex < 0) nextIndex = items.length - 1;
        if (nextIndex >= items.length) nextIndex = 0;
        items.forEach(el => el.classList.remove('is-active'));
        const next = items[nextIndex];
        next.classList.add('is-active');
        next.scrollIntoView({ block: 'nearest' });
        e.preventDefault();
      }

      if (e.key === 'Enter') {
        const active = document.querySelector('.search-result-item.is-active') as HTMLElement | null;
        if (active) {
          const slug = active.getAttribute('data-slug');
          if (slug) window.location.href = `/blog/${slug}/`;
        }
      }
    });
  }

  function performSearch(query: string) {
    if (!searchState.isInitialized || query.length < 2) {
      return;
    }

    searchState.isSearching = true;
    showLoading();
    
    // Use client-side search
    setTimeout(() => {
      const postsData = (window as any).__SEARCH_POSTS__ || [];
      const results = performClientSideSearch(postsData, query);
      handleSearchResults(results);
    }, 100);
  }

  function performClientSideSearch(posts: any[], query: string): SearchResult[] {
    if (!posts || posts.length === 0) return [];
    
    const results: SearchResult[] = [];
    const queryLower = query.toLowerCase();
    
    posts.forEach(post => {
      let score = 0;
      const matches: any[] = [];
      
      // Search in title
      if (post.title && post.title.toLowerCase().includes(queryLower)) {
        score += 0.4;
        matches.push({
          key: 'title',
          value: post.title,
          indices: [[post.title.toLowerCase().indexOf(queryLower), post.title.toLowerCase().indexOf(queryLower) + query.length - 1]]
        });
      }
      
      // Search in excerpt
      if (post.excerpt && post.excerpt.toLowerCase().includes(queryLower)) {
        score += 0.3;
        matches.push({
          key: 'excerpt',
          value: post.excerpt,
          indices: [[post.excerpt.toLowerCase().indexOf(queryLower), post.excerpt.toLowerCase().indexOf(queryLower) + query.length - 1]]
        });
      }
      
      // Search in content
      if (post.content && post.content.toLowerCase().includes(queryLower)) {
        score += 0.2;
        matches.push({
          key: 'content',
          value: post.content,
          indices: [[post.content.toLowerCase().indexOf(queryLower), post.content.toLowerCase().indexOf(queryLower) + query.length - 1]]
        });
      }
      
      // Search in category
      if (post.category && post.category.toLowerCase().includes(queryLower)) {
        score += 0.1;
        matches.push({
          key: 'category',
          value: post.category,
          indices: [[post.category.toLowerCase().indexOf(queryLower), post.category.toLowerCase().indexOf(queryLower) + query.length - 1]]
        });
      }
      
      if (score > 0) {
        results.push({
          item: post,
          score: score,
          matches: matches
        });
      }
    });
    
    // Sort by score (higher is better)
    return results.sort((a, b) => (b.score || 0) - (a.score || 0));
  }

  function handleSearchResults(results: SearchResult[]) {
    searchState.isSearching = false;
    hideLoading();
    
    const searchResults = document.getElementById('search-results') as HTMLDivElement;
    const searchResultsContent = document.getElementById('search-results-content') as HTMLDivElement;
    
    if (!searchResults || !searchResultsContent) return;
    
    if (results.length === 0) {
      searchResultsContent.innerHTML = `
        <div class="search-no-results">
          <p>Tidak ada artikel untuk "${searchState.currentQuery}"</p>
        </div>
      `;
    } else {
      searchResultsContent.innerHTML = results.map(result => {
        const img = result.item.heroSrc ? `<img src="${result.item.heroSrc}" alt="${result.item.title}" class="search-result-thumb" loading="lazy" />` : '';
        return `
        <div class="search-result-item" role="option" tabindex="0" data-slug="${result.item.slug}">
          ${img}
          <div class="search-result-body">
            <h3 class="search-result-title">${highlightMatches(result.item.title, result.matches, 'title')}</h3>
            ${result.item.excerpt ? `<p class="search-result-excerpt">${highlightMatches(result.item.excerpt, result.matches, 'excerpt')}</p>` : ''}
            <div class="search-result-meta">
              ${result.item.category ? `<span class="search-result-category">${result.item.category}</span>` : ''}
              ${result.item.dateLabel ? `<span class="search-result-date">${result.item.dateLabel}</span>` : ''}
            </div>
          </div>
        </div>`;
      }).join('');
      
      // Add click handlers to result items
      searchResultsContent.querySelectorAll('.search-result-item').forEach(item => {
        item.addEventListener('click', () => {
          const slug = item.getAttribute('data-slug');
          if (slug) {
            window.location.href = `/blog/${slug}/`;
          }
        });
        item.addEventListener('mouseover', () => {
          document.querySelectorAll('.search-result-item').forEach(el => el.classList.remove('is-active'));
          item.classList.add('is-active');
        });
      });
    }
    
    showResults();
    // Update ARIA expanded
    const searchInput = document.getElementById('search-input') as HTMLInputElement | null;
    if (searchInput) searchInput.setAttribute('aria-expanded', 'true');
  }

  function highlightMatches(text: string, matches: any[] | undefined, key: string): string {
    if (!matches) return text;
    
    const match = matches.find(m => m.key === key);
    if (!match || !match.indices.length) return text;
    
    let highlighted = '';
    let lastIndex = 0;
    
    match.indices.forEach(([start, end]: [number, number]) => {
      highlighted += text.slice(lastIndex, start);
      highlighted += `<mark class="search-highlight">${text.slice(start, end + 1)}</mark>`;
      lastIndex = end + 1;
    });
    
    highlighted += text.slice(lastIndex);
    return highlighted;
  }

  function showResults() {
    const searchResults = document.getElementById('search-results') as HTMLDivElement;
    if (searchResults) {
      searchResults.style.display = 'block';
    }
  }

  function hideResults() {
    const searchResults = document.getElementById('search-results') as HTMLDivElement;
    if (searchResults) {
      searchResults.style.display = 'none';
    }
    const searchInput = document.getElementById('search-input') as HTMLInputElement | null;
    if (searchInput) searchInput.setAttribute('aria-expanded', 'false');
  }

  function showLoading() {
    const searchLoading = document.getElementById('search-loading') as HTMLDivElement;
    if (searchLoading) {
      searchLoading.style.display = 'flex';
    }
  }

  function hideLoading() {
    const searchLoading = document.getElementById('search-loading') as HTMLDivElement;
    if (searchLoading) {
      searchLoading.style.display = 'none';
    }
  }

  // Initialize search function
  function initSearchFunction() {
    // Check if we're on the blog page
    if (!window.location.pathname.startsWith('/blog')) {
      return;
    }
    
    initSearch();
  }

  // Setup router reinit for ClientRouter compatibility
  let routerSetup = false;
  function setupRouterReinit() {
    if (routerSetup) return;
    routerSetup = true;

    const run = () => initSearchFunction();

    // Astro transitions events (if ClientRouter is used)
    document.addEventListener('astro:page-load', run);
    document.addEventListener('astro:after-swap', run);

    // Navigation via history
    window.addEventListener('popstate', run);
    const _push = history.pushState?.bind(history);
    if (_push) {
      history.pushState = function (
        data: any,
        unused: string,
        url?: string | URL | null
      ) {
        const ret = _push(data, unused, url);
        // re-bind after navigation
        setTimeout(run, 10);
        return ret;
      } as typeof history.pushState;
    }

    // Observe DOM changes to catch newly injected content
    const debounced = (() => {
      let t: number | null = null;
      return () => {
        if (t) window.clearTimeout(t);
        t = window.setTimeout(() => {
          run();
          t = null;
        }, 25);
      };
    })();

    const observer = new MutationObserver(debounced);
    observer.observe(document.body, { childList: true, subtree: true });
  }

  // Initialize when DOM is ready
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => {
      initSearchFunction();
      setupRouterReinit();
    });
  } else {
    initSearchFunction();
    setupRouterReinit();
  }
</script>
