---
import { Image } from "astro:assets";
import type { ImageMetadata } from "astro";
import { getContentImageConfig } from "@lib/images";

interface Props {
  src: string;
  alt?: string;
  width?: number | string;
  height?: number | string;
  loading?: "eager" | "lazy";
  class?: string;
}

/**
 * ContentImage: Override for the <img> tag in Markdown/MDX.
 * - Tries to resolve local images in the blog/downloads collections to ImageMetadata so they can be rendered via astro:assets.Image.
 * - If resolution fails (e.g. external/public URLs), falls back to a regular <img> with the same attributes.
 * - Global CSS .prose img will still apply to <img> results from <Image> because of the <picture><img> output.
 */
const {
  src,
  alt = "",
  loading = "lazy",
  class: cls,
} = Astro.props as Props;

// Normalize relative path like "./images/foo.jpg" -> "images/foo.jpg"
const normalized = src.replace(/^\.\/+/, "").replace(/^\//, "");

// Eager import metadata for all local images in the content collections
const blogMap = import.meta.glob("../../content/blog/**/*.{jpg,jpeg,png,webp,gif,svg}", {
  eager: true,
  import: "default",
});
const dlMap = import.meta.glob("../../content/downloads/**/*.{jpg,jpeg,png,webp,gif,svg}", {
  eager: true,
  import: "default",
});

function resolveLocalImage(path: string): ImageMetadata | null {
  for (const [p, meta] of Object.entries(blogMap)) {
    if (p.endsWith(path)) return meta as ImageMetadata;
  }
  for (const [p, meta] of Object.entries(dlMap)) {
    if (p.endsWith(path)) return meta as ImageMetadata;
  }
  return null;
}

const meta = resolveLocalImage(normalized);
const { widths, sizes } = getContentImageConfig();
---

{meta ? (
  <Image
    src={meta}
    alt={alt}
    loading={loading}
    decoding="async"
    widths={widths}
    sizes={sizes}
    class={cls}
  />
) : (
  <img src={src} alt={alt} loading={loading} decoding="async" class={cls} />
)}